<<<<<<< HEAD
# 字符串

不可变：改变 == 新创建，线程安全，js、python、go

可变：线程安全问题，c、c++、swift



# 比较算法

暴力：一个一个向后挨个匹配，O(mn)

Rabin-Karp：找到一个相同的，则取出n个长度的字符串，比较其与pattern的hash是否一致，一致则用暴力法确认，不一致则跳过继续下一个。

- hash算法：O(1)，滑动窗口。256个字符，则采用256进制，同十进制二进制，与当前字符串的ASCII值进行计算，结果模一个素数后作为hash。对于最高位的权重也需模该素数（如9997）。当滑动窗口向右移动一位时，减掉原来最高位的值后*256，再加上新加入的值，作为新的hash

KMP：匹配到某个元素不同，则在前面的元素中找到最长的与前缀相同的后缀，并以此作为下一个比较的开始元素
=======
[TOC]

# 关系

递归：自己调用自己

分治：递归处理、非递归处理

动态规划：

- 分治 + 最优子结构，即分治过程中进行优化（如去重、去掉次优解），如斐波那锲数列，即分治 + 记忆化 = 动态规划
- 顺推形式：动态地推，自底向上，递归有时是自顶向下，如斐波那锲数列，一般用 f(6) -> f(1)，若采用动态规划，则 f(0) -> f(6)
- 重点与难点：
  - dp 的定义
  - 状态转移方程：最大值、最小值、累加、累减、直接用前面的dp

**动态规划与递归或分治没有根本上的区别（关键看有无最优子结构）**
>>>>>>> 8e95561bd70680e0893f29c50dc5284d60275c3d
